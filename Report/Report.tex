\input{Setup.tex}

\hypersetup{
  pdftitle={Big Operators in Agda},
  pdfauthor={Leonhard Markert (lm510), Emmanuel College}
}
\title{Big Operators in Agda}
\author{Leonhard Markert \\ Emmanuel College}

%%% Body
\begin{document}

\begin{titlepage}
\maketitle
\tableofcontents
\end{titlepage}

\chapter{Introduction}

\section{Motivation}

\section{Logic and types}

XXX todo:
\begin{itemize}
\item Ignoring universes / levels in this report.
\item Value and \enquote{canonical element} used interchangeably.
\item Alpha-, beta-, eta-conversion. Basics of typed lambda calculus.
\item Truth = type inhabitation, falsity = absurdity
\end{itemize}

In this section, I will briefly review the connection between logic and type theory known as the \enquote{Curry-Howard correspondence}. It lies at the heart of all type theory-based theorem provers.

Fundamentally, to do automated reasoning in a mathematical logic (as opposed to, say, common-sense reasoning), three components are required:

\begin{description}
\item[Propositions and proofs] need to be represented within the system. In typed lambda calculi, propositions are represented as types and lambda terms correspond to proofs.
\item[Deduction rules] must be defined. Typing rules play this role in typed lambda calculi. Logics that can be represented in this way include intuitionistic propositional and predicate logics of various kinds as well as classical logics.
\item[Automation] makes the proof writer's job easier. There are several approaches to automation in different proof assistants based on the Curry-Howard correspondence. Agda, the theorem prover I used in my project, allows for interactive refinement of terms/proofs in a development environment.\footnote{Agda (\url{http://wiki.portal.chalmers.se/agda/pmwiki.php}) uses the proof search tool \emph{Agsy} \autocite{lindblad_tool_2006} to find terms (proofs) in the current scope that have a certain type (prove a given proposition).}
\end{description}

In order to use type theories as theorem provers, \emph{type checking} must be decidable: given a term and a type, the type checker can always tell whether or not the term has this particular type. This translates to \enquote{proposition checking} via the Curry-Howard correspondence: in the logics corresponding to that type theory, we can always decide if a given proof actually proves a certain proposition.

% An advantage of using typed lambda calculi to represent logic is that by stripping away the types, we can easily extract lambda terms that can be executed, giving us verified software for free---this is usually referred to as the \emph{computational fragment} of the typed lambda calculus.

\subsection{Basic notions and notation}

Familiarity with some notions from logic and type theory will be assumed in later sections. To make this report self-contained, I include a brief introduction here.

\minisec{Logic}

Basic notions in logic include propositions, judgements and contexts. Inference rules and tree-shaped formal proofs are commonly used notations.

\begin{description}
\item[Propositions] are generated from the grammar of the logic. For example, in a logic consisting of the constants \(\top\) and \(\bot\) and the logical connectives \(\_\!\!\wedge\!\!\_\) and \(\_\!\!\rightarrow\!\!\_\), we can construct the propositions \(\top \wedge \bot\), \(\bot \rightarrow \bot\), \(\bot \rightarrow ((\bot \wedge \top) \rightarrow \bot)\) and so on. Usually \(A, B, C\) range over propositions.
\item[Contexts] are sets of propositions. \(\Gamma\) and \(\Delta\) are commonly used to denote contexts.
\item[Judgements] have the form \(\Gamma \vdash A\) where \(\Gamma\) is a context and \(A\) is a proposition. The meaning of such a statement is \enquote{if the propositions in \(\Gamma\) hold, then it can be shown that \(A\) holds}.
\end{description}

As an example of an \emph{inference rule}, take the rule that introduces the logical connective \(\_\!\!\wedge\!\!\_\):

\begin{figure}[h]
\begin{prooftree}
    \AxiomC{\(\Gamma \vdash A\)}
    \AxiomC{\(\Delta \vdash B\)}
    \LeftLabel{(\(\wedge\)I)}
    \BinaryInfC{\(\Gamma,\Delta \vdash A \wedge B\)}
\end{prooftree}
\end{figure}

The premisses (zero or more) are written above the line and the conclusion (exactly one) below it. \(\Gamma,\Delta\) is common notation for \(\Gamma \cup \Delta\). Rules without premisses are called \enquote{axioms}. The above rule is meant to be read \enquote{assuming that if all propositions in \(\Gamma\) hold then \(A\) holds and also that if all propositions in \(\Delta\) hold then \(B\) holds, we can conclude that if all propositions in \(\Gamma \cup \Delta\) hold then \(A \wedge B\) holds.}

Rules and axioms are combined into tree-shaped proofs like the one in \cref{fig:example-proof}. Two more notational conventions are used here: an assumption-free judgement \(\{\} \vdash A\) is written \(\vdash A\), and usually the curly braces around the set of assumptions is not written, so one will commonly see \(A,B \vdash C\) instead of \(\{A,B\} \vdash C\).

\begin{figure}[h]
\begin{prooftree}
    \AxiomC{}
    \LeftLabel{\scriptsize{(axiom)}}
    \UnaryInfC{\(B \wedge A \vdash B \wedge A\)}
    \LeftLabel{\scriptsize{(\(\wedge\)E)}}
    \UnaryInfC{\(B \wedge A \vdash A\)}
    \AxiomC{}
    \LeftLabel{\scriptsize{(axiom)}}
    \UnaryInfC{\(B \wedge A \vdash B \wedge A\)}
    \LeftLabel{\scriptsize{(\(\wedge\)E)}}
    \UnaryInfC{\(B \wedge A \vdash B\)}
    \LeftLabel{\scriptsize{(\(\wedge\)I)}}
    \BinaryInfC{\(B \wedge A \vdash A \wedge B\)}
    \LeftLabel{\scriptsize{(\(\rightarrow\)I)}}
    \UnaryInfC{\(\vdash (B \wedge A) \rightarrow (A \wedge B)\)}
    \AxiomC{}
    \LeftLabel{\scriptsize{(axiom)}}
    \UnaryInfC{\(B \vdash B\)}
    \AxiomC{}
    \LeftLabel{\scriptsize{(axiom)}}
    \UnaryInfC{\(A \vdash A\)}
    \LeftLabel{\scriptsize{(\(\wedge\)I)}}
    \BinaryInfC{\(A,B \vdash B \wedge A\)}
    \LeftLabel{\scriptsize{(\(\rightarrow\)E)}}
    \BinaryInfC{\(A,B \vdash A \wedge B\)}
\end{prooftree}
\caption{A roundabout proof. This example is taken from \textcite{wadler_proofs_2000}.}
\label{fig:example-proof}
\end{figure}


\minisec{Type theory}

The typed lambda calculi that will be discussed in this survey all require the following notions:

\begin{description}
\item[Types] can be thought of as collections of objects. Often types are identified with sets, that is, a typing \(x:A\) (\enquote{\(x\) is of type \(A\)}) is equivalent to \(x \in A\) (\enquote{\(x\) is a member of \(A\)}). Basic types like Bool and \(\mathbb{N}\) (natural numbers) together with type constructors like \(\_\!\!\rightarrow\!\!\_\) (for function types) and \(\_\!\!\times\!\!\_\) (for pairs) constitute a grammar of types.
\item[Contexts] are finite partial functions from variables to types, usually written as \(\Gamma = \{x:A,y:B,\dots\}\) where \(\Gamma\) is the name of the context, \(x\) and \(y\) are variables and \(A\) and \(B\) types. In some type theories, order matters---in this case, contexts are ordered lists of (variable, type) tuples.
\item[Judgements] are written \(\Gamma \vdash t:A\) where \(\Gamma\) is a context, \(t\) is a term in the calculus and \(A\) a type. Such a judgement should be read as \enquote{assuming that the variables occurring free in \(t\) have the types that \(\Gamma\) assigns to them, then it can be shown that \(t\) has type \(A\)}.
\end{description}

Typing judgements are the counterpart to inference rules in logic. The rule for introducing pairs is:

\begin{figure}[h]
\begin{prooftree}
    \AxiomC{\(\Gamma \vdash t:A\)}
    \AxiomC{\(\Delta \vdash u:B\)}
    \LeftLabel{(\(\times\)I)}
    \BinaryInfC{\(\Gamma,\Delta \vdash (t, u) : A \times B\)}
\end{prooftree}
\end{figure}

Premiss, conclusion and axiom have the same meaning as in logic. Typing derivations are built up from typing rules and axioms in the same way that proofs are built from the rules and axioms of logic.

\section{Relations, predicates and decidability}

XXX intro blurb

\minisec{Relations}

Usually in mathematics, a relation between two sets is defined as a subset of the cartesian product of the two sets. In a dependent type theory, a binary relation between types \mintinline{agda}{A : Set} and \mintinline{agda}{B : Set} has the type \mintinline{agda}{A → B → Set}. Via currying, this type is isomorphic to \mintinline{agda}{A × B → Set}. A common way to think about this constructive way of defining relations is to view the resulting type as evidence that the two arguments are related.

We will restrict our attention to the special case of relations between inhabitants of the same type, called \emph{homogeneous} relations.

\emph{Divisibility} is a familiar notion with a straightforward definition as a type.

\begin{listing}[h]
\begin{agdacode}
data _∣_ : ℕ → ℕ → Set where
  divides : {m n : ℕ} (q : ℕ) (eq : n ≡ q * m) → m ∣ n
\end{agdacode}
\end{listing}

Its definition translates to \enquote{\(m\) divides \(n\) if there exists a \(q\) such that \(n \equiv q m\)}.

An important homogeneous binary relation is called \emph{propositional equality}, written as \(\_\!\!\equiv\!\!\_\) in Agda (also called \(I\) in the literature). Two elements of the same type are propositionally equal if they can be shown to reduce to the same value.

\begin{listing}[h]
\begin{agdacode}
data _≡_ {a} {A : Set a} (x : A) : A → Set a where
  refl : x ≡ x
\end{agdacode}
\end{listing}

The relation \(\_\!\!\equiv\!\!\_\) has only one constructor called \mintinline{agda}{refl}. In order to create an inhabitant of the propositional equality type, we must use this constructor---there is no other way.

The constructor \mintinline{agda}{refl} requires that its two arguments have the same value. Therefore, in order to obtain an inhabitant of \mintinline{agda}{x ≡ y}, \mintinline{agda}{x} and \mintinline{agda}{y} must be shown to reduce to the same value.

\minisec{Predicates}

A predicate expresses some property of a term. In constructive logic, we often think of the values of a predicate as the \emph{evidence} that it holds. The type of a predicate over a type \mintinline{agda}{A} is \mintinline{agda}{A → Set}.

We will consider two predicates over natural numbers as examples in this chapter, \mintinline{agda}{Even : ℕ → Set} and \mintinline{agda}{Collatz : ℕ → Set}. In words, they mean the following:
\begin{itemize}
\item \mintinline{agda}{Even n} provides evidence that \mintinline{agda}{n} is an even number. One way of defining this predicate is by stating that any even number is either equal to zero, or it is the successor of the successor of an even number.
\item \mintinline{agda}{Collatz n} provides evidence that if we keep iterating the function \(f\) (defined below), starting with \(f (n + 1)\), eventually the result will be the number \(1\).
\[ f(n) =
	\begin{cases}
		n/2    & \text{if } n \equiv 0 \text{ (mod \(2\))} \\
		3n + 1 & \text{if } n \equiv 1 \text{ (mod \(2\))}
	\end{cases}
\]
We can provide evidence for this property by giving a natural number \(i\) together with a proof that \(f^i(n+1) \equiv 1\), where \(f^i\) represents the function \(f\) iterated \(i\) times.
\end{itemize}

\begin{listing}[h]
\begin{agdacode}
data Even : ℕ → Set where
  zero-even : Even zero
  ss-even   : {n : ℕ} → Even n → Even (suc (suc n))
\end{agdacode}
\end{listing}

\begin{listing}[h]
\begin{agdacode}
Collatz : ℕ → Set
Collatz n = ∃ λ m → iter f (suc n) m ≡ 1
  where
    f : ℕ → ℕ
    f n with n mod 2
    f n | zero     = n div 2
    f n | suc zero = suc (3 * n)
    f n | suc (suc ())

    iter : ∀ {A} → (A → A) → A → ℕ → A
    iter f x zero    = x
    iter f x (suc n) = iter f (f x) n
\end{agdacode}
\end{listing}

\minisec{Decidability}

The notion of relation and predicate as introduced above is very general. One question we may ask is whether there exists a terminating decision procedure for a given relation or predicate. In the case of a predicate \mintinline{agda}{P : A → Set}, a decision procedure would be a function which for any argument \mintinline{agda}{x : A} returns either an inhabitant of type \mintinline{agda}{P x} (evidence that the predicate holds) or an inhabitant of type \mintinline{agda}{¬ P x} (evidence that the predicate does not hold).

Considering the two example again, a decision procedure for \mintinline{agda}{Even} is not entirely trivial, but still straightforward to define. The predicate \mintinline{agda}{Collatz}, on the other hand, has been shown by Conway (XXX reference) to be undecidable---this is an instance of a predicate for which no decision procedure exists.

\section{Equivalences and setoids}

The main use case of the agda-bigops library is to prove equalities. As an example, the Binomial Theorem can be stated as \[ (1 + x)^n = \sum_{k = 0}^n \binom{n}{k} \; x^k \]

The intended meaning of this equation seems clear---in English, the statement could be expressed as as follows: \begin{quote}For all numbers \(x\) and \(n\), let \(k\) range over all numbers from \(0\) to \(n\) and evaluate \(\binom{n}{k} \; x^k\) at each step. The sum of all those numbers is equal to the number obtained by evaluating \((1 + x)^n\).\end{quote}

Unfortunately, this description is too imprecise to be translated into a statement of formal mathematics. The first question we would have to answer is what \emph{kinds} of numbers \(x\) and \(n\) are. The notation suggests that \(n\) is an integer. It does not tell us whether the equation is supposed to hold if \(n\) is negative. The number \(x\) is less constrained by notation as exponentiation is defined even for complex and irrational numbers. Is the equation meant to cover them too?

Next, we have to define the meaning of each symbol that occurs in the formula. The definition of summation, exponentiation and binomial coefficients can be found in any mathematics textbook. The \enquote{big sum} symbol has two different obvious definitions (see XXX), but in this case they both turn out to evaluate to the same result.

The last thing we need to consider is the meaning of the equality sign. In dependent types based logics, this is where equivalences and setoids come in.

\minisec{Equivalences}

Equivalences capture the essence of what it means for two things to be equal. A relation \(\_\!\!\approx\!\!\_\) is an equivalence if it is \emph{reflexive} (\(\forall a.\ a \approx a\)), \emph{symmetric} (\(\forall a,b.\ a \approx b \rightarrow b \approx a\)) and \emph{transitive} (\(\forall a,b,c.\ a \approx b \wedge b \approx c \rightarrow a \approx c\)).

It is easy to see that the notion of equality we used in the example at the beginning of this section is an equivalence. Informally, it can be stated as \enquote{two terms are equivalent if they evaluate to the same number}. This intuition is captured by an equivalence called \emph{propositional equality}, written as \(\_\!\!\equiv\!\!\_\) in Agda (also called \(I\) in the literature). Two elements of the same type are propositionally equal if they can be shown to reduce to the same expression.

\minisec{Setoids}

A \emph{setoid} packages a type, called the \emph{carrier}, with an equivalence relation defined on that type. In the Agda standard library, the equivalence is split up into its underlying relation and a proof that this relation is an equivalence (see \cref{lst:setoid}).

\begin{listing}[h]
    \begin{agdacode}
record Setoid c ℓ : Set (suc (c ⊔ ℓ)) where
  infix 4 _≈_
  field
    Carrier       : Set c
    _≈_           : Rel Carrier ℓ
    isEquivalence : IsEquivalence _≈_
    \end{agdacode}
    \label{lst:setoid}
    \caption{The definition of a setoid in the Agda standard library.}
\end{listing}

% Σ[ k ← 0 … n $ n choose k * x ^ k ] ≈ (suc x) ^ n

\section{Algebra}

\chapter{Implementation}

\section{Design}

\section{Differences to big operators in Coq}

\chapter{Evaluation}

\section{Theorems proved}

\appendix

\chapter{Semiring of square matrices}

\end{document}
